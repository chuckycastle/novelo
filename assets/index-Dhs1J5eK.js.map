{"version":3,"file":"index-Dhs1J5eK.js","sources":["../../src/config/puzzle.ts","../../src/core/geometry.ts","../../src/core/matching.ts","../../src/core/timer.ts","../../src/input/pointer-handler.ts","../../src/state/selection-state.ts","../../src/state/game-state.ts","../../src/ui/grid.ts","../../src/ui/word-list.ts","../../src/ui/timer-display.ts","../../src/ui/screens.ts","../../src/main.ts"],"sourcesContent":["import type { PuzzleConfig } from '../types';\n\nexport const familyPuzzle: PuzzleConfig = {\n  title: 'NOVELO Name Search',\n  description: 'Find the names of the NOVELOs hidden in the grid. Names can appear forwards, backwards, or diagonally.',\n  grid: [\n    'MXXOXCZVYAXKQYRLTTSE',\n    'GAIPAZSQWDANENTSEWQP',\n    'NNRCBLAWPNQGZAUZAOAX',\n    'OAYLXDIJQMJEGHWFPNJA',\n    'DQTKEJRLNOBUPXRAKHSV',\n    'IUJHXNFREAEENPIFFLKV',\n    'DEALAEEDIWUDSPCAVCWT',\n    'PCXXTNNSGGYGDSALEENU',\n    'DUCSEWILLFTSHFYPWVTE',\n    'OJRLILQEAZTXTESRGCTQ',\n    'TCAMITAFLBTEMBWGCGSO',\n    'WYHCMZERJNUXKPLADTDP',\n    'XQSAHSVGYNQRHIFCHZYW',\n    'BKTLBAJGCAQXWNAGJEUN',\n    'PTBQIETOZKLDZCWAVXCI',\n    'XZBTSDLOTAWUMFSADEAR',\n    'GLXDLHPIVLQAAIKWYRAZ',\n    'FBGPVMIDTSELEPJSKZSV',\n    'SSMPUEDAJAYLBKGICHII',\n    'PSUMHLKAZTUNDGOHAEWW',\n  ],\n  words: [\n    'FATIMA',\n    'PAULA',\n    'DILSY',\n    'NENA',\n    'CHATO',\n    'FAFA',\n    'MARLENE',\n    'SALEEN',\n    'CHABELITA',\n    'ALEXA',\n    'NATHANIEL',\n    'JADE',\n    'JASIEL',\n    'ISAAC',\n    'JOEL',\n  ],\n};\n\nexport const GRID_SIZE = 20;\n","import type { Direction, Position } from '../types';\n\n/**\n * Check if two positions form a valid straight line (horizontal, vertical, or diagonal)\n */\nexport function isValidLine(start: Position, end: Position): boolean {\n  const dRow = Math.abs(end.row - start.row);\n  const dCol = Math.abs(end.col - start.col);\n\n  // Same position is not a valid line\n  if (dRow === 0 && dCol === 0) return false;\n\n  // Horizontal, vertical, or diagonal (45 degrees)\n  return dRow === 0 || dCol === 0 || dRow === dCol;\n}\n\n/**\n * Get the direction vector between two positions\n */\nexport function getDirection(start: Position, end: Position): Direction {\n  const dRow = end.row - start.row;\n  const dCol = end.col - start.col;\n\n  return {\n    dRow: dRow === 0 ? 0 : dRow / Math.abs(dRow),\n    dCol: dCol === 0 ? 0 : dCol / Math.abs(dCol),\n  };\n}\n\n/**\n * Check if two directions are the same\n */\nexport function isSameDirection(a: Direction, b: Direction): boolean {\n  return a.dRow === b.dRow && a.dCol === b.dCol;\n}\n\n/**\n * Get all positions along a line from start to end (inclusive)\n */\nexport function getLineCells(start: Position, end: Position): Position[] {\n  if (!isValidLine(start, end)) return [];\n\n  const cells: Position[] = [];\n  const direction = getDirection(start, end);\n  const length = Math.max(Math.abs(end.row - start.row), Math.abs(end.col - start.col)) + 1;\n\n  for (let i = 0; i < length; i++) {\n    cells.push({\n      row: start.row + direction.dRow * i,\n      col: start.col + direction.dCol * i,\n    });\n  }\n\n  return cells;\n}\n\n/**\n * Check if a position is adjacent to another (including diagonals)\n */\nexport function isAdjacent(a: Position, b: Position): boolean {\n  const dRow = Math.abs(a.row - b.row);\n  const dCol = Math.abs(a.col - b.col);\n  return dRow <= 1 && dCol <= 1 && !(dRow === 0 && dCol === 0);\n}\n\n/**\n * Check if a position is within grid bounds\n */\nexport function isInBounds(pos: Position, gridSize: number): boolean {\n  return pos.row >= 0 && pos.row < gridSize && pos.col >= 0 && pos.col < gridSize;\n}\n\n/**\n * Check if two positions are equal\n */\nexport function positionsEqual(a: Position, b: Position): boolean {\n  return a.row === b.row && a.col === b.col;\n}\n\n/**\n * Find position index in a path\n */\nexport function findPositionInPath(path: readonly Position[], pos: Position): number {\n  return path.findIndex((p) => positionsEqual(p, pos));\n}\n\n/**\n * Snap pointer delta to one of 8 cardinal/diagonal directions.\n * Uses slope thresholds to determine if movement is horizontal, vertical, or diagonal.\n */\nexport function snapToDirection(dx: number, dy: number): Direction {\n  // Handle zero movement\n  if (dx === 0 && dy === 0) {\n    return { dRow: 0, dCol: 0 };\n  }\n\n  // Handle pure vertical\n  if (dx === 0) {\n    return { dRow: dy > 0 ? 1 : -1, dCol: 0 };\n  }\n\n  // Handle pure horizontal\n  if (dy === 0) {\n    return { dRow: 0, dCol: dx > 0 ? 1 : -1 };\n  }\n\n  const slope = Math.abs(dy / dx);\n\n  // Determine if diagonal (slope near 1) or axis-aligned\n  // Thresholds: < 0.5 = horizontal, > 2.0 = vertical, else diagonal\n  if (slope < 0.5) {\n    // Horizontal\n    return { dRow: 0, dCol: dx > 0 ? 1 : -1 };\n  } else if (slope > 2.0) {\n    // Vertical\n    return { dRow: dy > 0 ? 1 : -1, dCol: 0 };\n  } else {\n    // Diagonal\n    return {\n      dRow: dy > 0 ? 1 : -1,\n      dCol: dx > 0 ? 1 : -1,\n    };\n  }\n}\n\n/**\n * Project pointer movement onto a locked direction line and compute the end cell.\n * Returns the grid cell that the projection points to.\n */\nexport function projectToGridCell(\n  startCell: Position,\n  dx: number,\n  dy: number,\n  direction: Direction,\n  cellSize: number,\n  gridSize: number,\n): Position {\n  // If no direction, return start\n  if (direction.dRow === 0 && direction.dCol === 0) {\n    return startCell;\n  }\n\n  // Project the pointer delta (in cells) onto the locked direction vector.\n  // This yields a signed scalar that matches the intended drag direction for all quadrants.\n  const deltaCols = dx / cellSize;\n  const deltaRows = dy / cellSize;\n  const steps = deltaCols * direction.dCol + deltaRows * direction.dRow;\n\n  // Round to nearest cell\n  const cellSteps = Math.round(steps);\n\n  // Calculate end position\n  const endRow = startCell.row + direction.dRow * cellSteps;\n  const endCol = startCell.col + direction.dCol * cellSteps;\n\n  // Clamp to grid bounds\n  return {\n    row: Math.max(0, Math.min(gridSize - 1, endRow)),\n    col: Math.max(0, Math.min(gridSize - 1, endCol)),\n  };\n}\n","import type { MatchResult, Position } from '../types';\n\n/**\n * Extract a word from the grid given a list of positions\n */\nexport function extractWord(grid: readonly string[], cells: readonly Position[]): string {\n  return cells.map(({ row, col }) => grid[row]?.[col] ?? '').join('');\n}\n\n/**\n * Check if a word matches any target word (forward or reversed)\n */\nexport function matchWord(\n  candidate: string,\n  targetWords: readonly string[],\n): { matched: boolean; word: string | null } {\n  const reversed = candidate.split('').reverse().join('');\n\n  for (const word of targetWords) {\n    if (word === candidate || word === reversed) {\n      return { matched: true, word };\n    }\n  }\n\n  return { matched: false, word: null };\n}\n\n/**\n * Try to match a selection against the word list\n */\nexport function tryMatch(\n  grid: readonly string[],\n  cells: readonly Position[],\n  targetWords: readonly string[],\n  foundWords: ReadonlySet<string>,\n): MatchResult {\n  if (cells.length < 2) {\n    return { matched: false, word: null, cells: [] };\n  }\n\n  const candidate = extractWord(grid, cells);\n  const result = matchWord(candidate, targetWords);\n\n  // Don't match already found words\n  if (result.matched && result.word && foundWords.has(result.word)) {\n    return { matched: false, word: null, cells: [] };\n  }\n\n  return {\n    matched: result.matched,\n    word: result.word,\n    cells: result.matched ? cells : [],\n  };\n}\n\n/**\n * Format a word for display (capitalize first letter)\n */\nexport function formatWordForDisplay(word: string): string {\n  return word.charAt(0) + word.slice(1).toLowerCase();\n}\n","export type TimerCallback = (formatted: string) => void;\n\n/**\n * High-precision timer using performance.now() and requestAnimationFrame\n * Displays time in MM:SS.ss format (centisecond precision)\n */\nexport class PrecisionTimer {\n  private startTime: number = 0;\n  private animationFrameId: number | null = null;\n  private onTick: TimerCallback;\n  private stopped: boolean = false;\n\n  constructor(onTick: TimerCallback) {\n    this.onTick = onTick;\n  }\n\n  /**\n   * Start the timer\n   */\n  start(): void {\n    this.startTime = performance.now();\n    this.stopped = false;\n    this.tick();\n  }\n\n  /**\n   * Stop the timer and return the final formatted time\n   */\n  stop(): string {\n    this.stopped = true;\n    if (this.animationFrameId !== null) {\n      cancelAnimationFrame(this.animationFrameId);\n      this.animationFrameId = null;\n    }\n    return this.format(performance.now() - this.startTime);\n  }\n\n  /**\n   * Get current elapsed time in milliseconds\n   */\n  getElapsed(): number {\n    return performance.now() - this.startTime;\n  }\n\n  /**\n   * Animation frame tick\n   */\n  private tick = (): void => {\n    if (this.stopped) return;\n\n    const elapsed = performance.now() - this.startTime;\n    this.onTick(this.format(elapsed));\n    this.animationFrameId = requestAnimationFrame(this.tick);\n  };\n\n  /**\n   * Format milliseconds as MM:SS.ss\n   */\n  private format(ms: number): string {\n    const totalSeconds = Math.floor(ms / 1000);\n    const minutes = Math.floor(totalSeconds / 60);\n    const seconds = totalSeconds % 60;\n    const centiseconds = Math.floor((ms % 1000) / 10);\n\n    return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}.${String(centiseconds).padStart(2, '0')}`;\n  }\n}\n\n/**\n * Format milliseconds as MM:SS.ss (static utility)\n */\nexport function formatTime(ms: number): string {\n  const totalSeconds = Math.floor(ms / 1000);\n  const minutes = Math.floor(totalSeconds / 60);\n  const seconds = totalSeconds % 60;\n  const centiseconds = Math.floor((ms % 1000) / 10);\n\n  return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}.${String(centiseconds).padStart(2, '0')}`;\n}\n","import type { Direction, Position } from '../types';\nimport { getLineCells, snapToDirection, projectToGridCell } from '../core/geometry';\nimport { GRID_SIZE } from '../config/puzzle';\n\nconst DRAG_THRESHOLD = 10; // pixels\n\ninterface PointerTracker {\n  startX: number;\n  startY: number;\n  startPosition: Position | null;\n  hasMoved: boolean;\n  // Direction locking for geometric drag\n  lockedDirection: Direction | null;\n  cellSize: number;\n}\n\nlet tracker: PointerTracker | null = null;\n\nexport interface PointerCallbacks {\n  onTapStart: (pos: Position) => void;\n  onTapEnd: (pos: Position) => void;\n  onDragStart: (pos: Position) => void;\n  onDragMove: (path: readonly Position[]) => void; // Changed: now receives computed path\n  onDragEnd: () => void;\n  onCancel: () => void;\n}\n\n/**\n * Get grid position from pointer event\n */\nfunction getPositionFromElement(element: Element | null): Position | null {\n  if (!element) return null;\n\n  // Some browsers fire events on text nodes; normalize to an element before calling closest\n  const target =\n    element instanceof Element ? element : (element as unknown as Node | null)?.parentElement;\n\n  if (!target) return null;\n\n  const cell = target.closest('[data-row][data-col]');\n  if (!cell) return null;\n\n  const row = parseInt(cell.getAttribute('data-row') ?? '', 10);\n  const col = parseInt(cell.getAttribute('data-col') ?? '', 10);\n\n  if (isNaN(row) || isNaN(col)) return null;\n\n  return { row, col };\n}\n\n/**\n * Setup pointer event handlers on the grid element\n */\nexport function setupPointerHandlers(\n  gridElement: HTMLElement,\n  callbacks: PointerCallbacks,\n): () => void {\n  const onPointerDown = (e: PointerEvent): void => {\n    const pos = getPositionFromElement(e.target as Element);\n    if (!pos) return;\n\n    // Prevent default to stop scrolling/text selection\n    e.preventDefault();\n\n    // Calculate cell size from grid dimensions\n    const gridRect = gridElement.getBoundingClientRect();\n    const cellSize = gridRect.width / GRID_SIZE;\n\n    // Store pointer info for drag detection\n    tracker = {\n      startX: e.clientX,\n      startY: e.clientY,\n      startPosition: pos,\n      hasMoved: false,\n      lockedDirection: null,\n      cellSize,\n    };\n\n    // Immediately notify tap start (for visual feedback)\n    callbacks.onTapStart(pos);\n  };\n\n  const onPointerMove = (e: PointerEvent): void => {\n    if (!tracker || !tracker.startPosition) return;\n\n    // Prevent default to stop scrolling while dragging\n    e.preventDefault();\n\n    const dx = e.clientX - tracker.startX;\n    const dy = e.clientY - tracker.startY;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n\n    // Check if we've crossed the drag threshold\n    if (!tracker.hasMoved && distance > DRAG_THRESHOLD) {\n      tracker.hasMoved = true;\n      // Lock direction based on initial movement vector\n      tracker.lockedDirection = snapToDirection(dx, dy);\n      // Only capture pointer once drag starts (not on tap)\n      // Wrap in try/catch as some mobile browsers don't support pointer capture\n      try {\n        gridElement.setPointerCapture(e.pointerId);\n      } catch {\n        // Pointer capture not supported, continue without it\n      }\n      callbacks.onDragStart(tracker.startPosition);\n    }\n\n    if (tracker.hasMoved && tracker.lockedDirection) {\n      // Project pointer position onto locked direction to get end cell\n      const endPos = projectToGridCell(\n        tracker.startPosition,\n        dx,\n        dy,\n        tracker.lockedDirection,\n        tracker.cellSize,\n        GRID_SIZE,\n      );\n\n      // Build path geometrically from start to projected end\n      const path = getLineCells(tracker.startPosition, endPos);\n      if (path.length > 0) {\n        callbacks.onDragMove(path);\n      }\n    }\n  };\n\n  const onPointerUp = (e: PointerEvent): void => {\n    if (!tracker) return;\n\n    if (tracker.hasMoved) {\n      // End drag\n      callbacks.onDragEnd();\n    } else {\n      // It was a tap - for tap, user didn't move so startPosition is most reliable\n      // On mobile, clientX/clientY may be unavailable after touch ends\n      // Priority: startPosition > elementFromPoint > e.target\n      let pos: Position | null = tracker.startPosition;\n      if (!pos) {\n        // Fallback to coordinate-based detection\n        if (e.clientX !== 0 || e.clientY !== 0) {\n          pos = getPositionFromElement(document.elementFromPoint(e.clientX, e.clientY));\n        }\n      }\n      if (!pos) {\n        pos = getPositionFromElement(e.target as Element);\n      }\n      if (pos) {\n        callbacks.onTapEnd(pos);\n      }\n    }\n\n    tracker = null;\n  };\n\n  const onPointerCancel = (): void => {\n    if (tracker) {\n      tracker = null;\n      callbacks.onCancel();\n    }\n  };\n\n  const onPointerLeave = (): void => {\n    // Only cancel if we don't have an active tracker (pointer not captured)\n    // With pointer capture on grid, this shouldn't fire during active interaction\n    if (!tracker) {\n      callbacks.onCancel();\n    }\n  };\n\n  // Add event listeners\n  gridElement.addEventListener('pointerdown', onPointerDown);\n  gridElement.addEventListener('pointermove', onPointerMove);\n  gridElement.addEventListener('pointerup', onPointerUp);\n  gridElement.addEventListener('pointercancel', onPointerCancel);\n  gridElement.addEventListener('pointerleave', onPointerLeave);\n\n  // Prevent context menu on long press\n  gridElement.addEventListener('contextmenu', (e) => e.preventDefault());\n\n  // Prevent touch scrolling on the grid\n  const onTouchMove = (e: TouchEvent): void => {\n    if (tracker) {\n      e.preventDefault();\n    }\n  };\n  gridElement.addEventListener('touchmove', onTouchMove, { passive: false });\n\n  // Return cleanup function\n  return () => {\n    gridElement.removeEventListener('pointerdown', onPointerDown);\n    gridElement.removeEventListener('pointermove', onPointerMove);\n    gridElement.removeEventListener('pointerup', onPointerUp);\n    gridElement.removeEventListener('pointercancel', onPointerCancel);\n    gridElement.removeEventListener('pointerleave', onPointerLeave);\n    gridElement.removeEventListener('touchmove', onTouchMove);\n  };\n}\n","import { positionsEqual } from '../core/geometry';\nimport type { Position, SelectionState } from '../types';\n\n/**\n * Create initial selection state\n */\nexport function createInitialSelection(): SelectionState {\n  return {\n    isActive: false,\n    startPosition: null,\n    currentPath: [],\n    mode: 'tap',\n  };\n}\n\n/**\n * Start a new selection\n */\nexport function startSelection(pos: Position, mode: 'tap' | 'drag'): SelectionState {\n  return {\n    isActive: true,\n    startPosition: pos,\n    currentPath: [pos],\n    mode,\n  };\n}\n\n/**\n * Clear current selection\n */\nexport function clearSelection(): SelectionState {\n  return createInitialSelection();\n}\n\n/**\n * Handle tap selection - either set start or complete the line\n */\nexport function handleTapSelection(\n  state: SelectionState,\n  pos: Position,\n): { state: SelectionState; shouldCheck: boolean } {\n  // If no active selection, start one\n  if (!state.isActive || state.startPosition === null) {\n    return {\n      state: startSelection(pos, 'tap'),\n      shouldCheck: false,\n    };\n  }\n\n  // If tapping the same cell, cancel selection\n  if (positionsEqual(state.startPosition, pos)) {\n    return {\n      state: clearSelection(),\n      shouldCheck: false,\n    };\n  }\n\n  // Complete the selection with the end position\n  return {\n    state: {\n      ...state,\n      currentPath: [state.startPosition, pos],\n    },\n    shouldCheck: true,\n  };\n}\n\n/**\n * Handle drag move - set the path directly (geometric calculation done by pointer handler)\n */\nexport function handleDragMove(state: SelectionState, path: readonly Position[]): SelectionState {\n  if (!state.isActive) return state;\n\n  return {\n    ...state,\n    currentPath: path,\n  };\n}\n\n/**\n * Complete a drag selection\n */\nexport function completeDragSelection(state: SelectionState): {\n  state: SelectionState;\n  shouldCheck: boolean;\n} {\n  return {\n    state,\n    shouldCheck: state.currentPath.length >= 2,\n  };\n}\n","import type { GameState } from '../types';\n\n/**\n * Create initial game state\n */\nexport function createInitialState(): GameState {\n  return {\n    phase: 'start',\n    foundWords: new Set<string>(),\n    startTime: null,\n    endTime: null,\n  };\n}\n\n/**\n * Transition to playing phase\n */\nexport function startGame(state: GameState): GameState {\n  return {\n    ...state,\n    phase: 'playing',\n    startTime: performance.now(),\n    endTime: null,\n  };\n}\n\n/**\n * Mark a word as found\n */\nexport function markWordFound(\n  state: GameState,\n  word: string,\n  totalWords: number,\n): GameState {\n  const newFoundWords = new Set(state.foundWords);\n  newFoundWords.add(word);\n\n  const isComplete = newFoundWords.size === totalWords;\n\n  return {\n    ...state,\n    foundWords: newFoundWords,\n    phase: isComplete ? 'complete' : state.phase,\n    endTime: isComplete ? performance.now() : state.endTime,\n  };\n}\n\n/**\n * Reset game to start state\n */\nexport function resetGame(): GameState {\n  return createInitialState();\n}\n\n/**\n * Get elapsed time in milliseconds\n */\nexport function getElapsedTime(state: GameState): number {\n  if (state.startTime === null) return 0;\n\n  const endTime = state.endTime ?? performance.now();\n  return endTime - state.startTime;\n}\n\n/**\n * Check if the game is complete\n */\nexport function isGameComplete(state: GameState): boolean {\n  return state.phase === 'complete';\n}\n\n/**\n * Check if the game is playing\n */\nexport function isGamePlaying(state: GameState): boolean {\n  return state.phase === 'playing';\n}\n","import type { Position } from '../types';\n\n/**\n * Render the word search grid\n */\nexport function renderGrid(\n  container: HTMLElement,\n  grid: readonly string[],\n  foundCells: ReadonlySet<string>,\n): void {\n  container.innerHTML = '';\n\n  grid.forEach((row, rowIndex) => {\n    [...row].forEach((letter, colIndex) => {\n      const cellKey = `${rowIndex},${colIndex}`;\n      const isFound = foundCells.has(cellKey);\n\n      const cell = document.createElement('button');\n      cell.type = 'button';\n      cell.className = `\n        w-7 h-7 sm:w-8 sm:h-8 md:w-9 md:h-9\n        flex items-center justify-center\n        border border-gray-300\n        font-semibold uppercase text-xs sm:text-sm\n        select-none touch-manipulation\n        transition-colors duration-100\n        focus:outline-none focus:ring-2 focus:ring-purple-400 focus:ring-offset-1\n        ${isFound ? 'bg-green-200 border-green-600 text-green-800' : 'bg-white hover:bg-purple-50'}\n      `.trim().replace(/\\s+/g, ' ');\n\n      cell.textContent = letter;\n      cell.dataset.row = String(rowIndex);\n      cell.dataset.col = String(colIndex);\n\n      if (isFound) {\n        cell.dataset.found = 'true';\n      }\n\n      container.appendChild(cell);\n    });\n  });\n}\n\n/**\n * Update cell highlighting for current selection path\n */\nexport function updateSelectionHighlight(\n  container: HTMLElement,\n  path: readonly Position[],\n): void {\n  // Clear all active states first\n  container.querySelectorAll('[data-active]').forEach((cell) => {\n    cell.removeAttribute('data-active');\n    cell.classList.remove('bg-purple-100', 'border-purple-500');\n    if (!cell.hasAttribute('data-found')) {\n      cell.classList.add('bg-white', 'hover:bg-purple-50');\n    }\n  });\n\n  // Apply active state to path cells\n  path.forEach((pos) => {\n    const cell = container.querySelector(`[data-row=\"${pos.row}\"][data-col=\"${pos.col}\"]`);\n    if (cell && !cell.hasAttribute('data-found')) {\n      cell.setAttribute('data-active', 'true');\n      cell.classList.remove('bg-white', 'hover:bg-purple-50');\n      cell.classList.add('bg-purple-100', 'border-purple-500');\n    }\n  });\n}\n\n/**\n * Mark cells as found (permanently green)\n */\nexport function markCellsFound(container: HTMLElement, cells: readonly Position[]): void {\n  cells.forEach((pos) => {\n    const cell = container.querySelector(`[data-row=\"${pos.row}\"][data-col=\"${pos.col}\"]`);\n    if (cell) {\n      cell.setAttribute('data-found', 'true');\n      cell.removeAttribute('data-active');\n      cell.classList.remove('bg-white', 'hover:bg-purple-50', 'bg-purple-100', 'border-purple-500');\n      cell.classList.add('bg-green-200', 'border-green-600', 'text-green-800');\n    }\n  });\n}\n\n/**\n * Generate a Set of found cell keys from positions\n */\nexport function createFoundCellsSet(positions: readonly Position[]): Set<string> {\n  return new Set(positions.map((p) => `${p.row},${p.col}`));\n}\n","import { formatWordForDisplay } from '../core/matching';\n\n/**\n * Render the word list sidebar\n */\nexport function renderWordList(\n  container: HTMLElement,\n  words: readonly string[],\n  foundWords: ReadonlySet<string>,\n): void {\n  container.innerHTML = '';\n\n  const list = document.createElement('ul');\n  list.className = 'grid grid-cols-3 sm:grid-cols-2 gap-x-2 sm:gap-x-4 gap-y-0.5 sm:gap-y-1 text-xs sm:text-sm';\n\n  words.forEach((word) => {\n    const isFound = foundWords.has(word);\n    const li = document.createElement('li');\n    li.className = `\n      flex items-center gap-2\n      ${isFound ? 'text-green-700 line-through' : 'text-gray-700'}\n    `.trim().replace(/\\s+/g, ' ');\n\n    const icon = document.createElement('span');\n    icon.textContent = isFound ? 'âœ“' : 'â€¢';\n    icon.className = isFound ? 'text-green-600 font-bold' : 'text-gray-400';\n\n    const text = document.createElement('span');\n    text.textContent = formatWordForDisplay(word);\n\n    li.appendChild(icon);\n    li.appendChild(text);\n    list.appendChild(li);\n  });\n\n  container.appendChild(list);\n}\n\n/**\n * Update the progress display\n */\nexport function updateProgress(\n  container: HTMLElement,\n  found: number,\n  total: number,\n): void {\n  const isComplete = found === total;\n\n  container.innerHTML = `\n    <span class=\"${isComplete ? 'text-green-600' : 'text-purple-600'} font-semibold\">\n      ${found}/${total}\n    </span>\n    ${isComplete ? ' ðŸŽ‰' : ''}\n  `;\n}\n","/**\n * Update the timer display\n */\nexport function updateTimerDisplay(container: HTMLElement, time: string): void {\n  container.textContent = time;\n}\n\n/**\n * Create initial timer display\n */\nexport function initTimerDisplay(container: HTMLElement): void {\n  container.textContent = '00:00.00';\n  container.className = 'font-mono text-2xl sm:text-3xl font-bold text-purple-600';\n}\n","/**\n * Show the start screen\n */\nexport function showStartScreen(onStart: () => void): void {\n  const screen = document.getElementById('start-screen');\n  const gameScreen = document.getElementById('game-screen');\n  const completeScreen = document.getElementById('complete-screen');\n\n  if (screen) screen.classList.remove('hidden');\n  if (gameScreen) gameScreen.classList.add('hidden');\n  if (completeScreen) completeScreen.classList.add('hidden');\n\n  const startBtn = document.getElementById('start-btn');\n  if (startBtn) {\n    // Remove old listener and add new one\n    const newBtn = startBtn.cloneNode(true) as HTMLButtonElement;\n    startBtn.parentNode?.replaceChild(newBtn, startBtn);\n    newBtn.addEventListener('click', onStart);\n  }\n}\n\n/**\n * Show the game screen\n */\nexport function showGameScreen(): void {\n  const screen = document.getElementById('start-screen');\n  const gameScreen = document.getElementById('game-screen');\n  const completeScreen = document.getElementById('complete-screen');\n\n  if (screen) screen.classList.add('hidden');\n  if (gameScreen) gameScreen.classList.remove('hidden');\n  if (completeScreen) completeScreen.classList.add('hidden');\n}\n\n/**\n * Show the completion screen\n */\nexport function showCompletionScreen(finalTime: string, onPlayAgain: () => void): void {\n  const screen = document.getElementById('start-screen');\n  const gameScreen = document.getElementById('game-screen');\n  const completeScreen = document.getElementById('complete-screen');\n  const timeDisplay = document.getElementById('final-time');\n\n  if (screen) screen.classList.add('hidden');\n  if (gameScreen) gameScreen.classList.add('hidden');\n  if (completeScreen) completeScreen.classList.remove('hidden');\n  if (timeDisplay) timeDisplay.textContent = finalTime;\n\n  const playAgainBtn = document.getElementById('play-again-btn');\n  if (playAgainBtn) {\n    // Remove old listener and add new one\n    const newBtn = playAgainBtn.cloneNode(true) as HTMLButtonElement;\n    playAgainBtn.parentNode?.replaceChild(newBtn, playAgainBtn);\n    newBtn.addEventListener('click', onPlayAgain);\n  }\n}\n","import { familyPuzzle } from './config/puzzle';\nimport { getLineCells, isValidLine } from './core/geometry';\nimport { tryMatch } from './core/matching';\nimport { PrecisionTimer } from './core/timer';\nimport { setupPointerHandlers } from './input/pointer-handler';\nimport {\n  clearSelection,\n  completeDragSelection,\n  createInitialSelection,\n  handleDragMove,\n  handleTapSelection,\n  startSelection,\n} from './state/selection-state';\nimport { positionsEqual } from './core/geometry';\nimport {\n  createInitialState,\n  markWordFound,\n  startGame,\n} from './state/game-state';\nimport {\n  markCellsFound,\n  renderGrid,\n  updateSelectionHighlight,\n} from './ui/grid';\nimport { renderWordList, updateProgress } from './ui/word-list';\nimport { initTimerDisplay, updateTimerDisplay } from './ui/timer-display';\nimport { showCompletionScreen, showGameScreen, showStartScreen } from './ui/screens';\nimport type { GameState, Position, SelectionState } from './types';\nimport './styles/main.css';\n\n// Global state\nlet gameState: GameState = createInitialState();\nlet selectionState: SelectionState = createInitialSelection();\nlet timer: PrecisionTimer | null = null;\nlet foundCells: Set<string> = new Set();\n\n// DOM elements\nlet gridContainer: HTMLElement | null = null;\nlet wordListContainer: HTMLElement | null = null;\nlet progressContainer: HTMLElement | null = null;\nlet timerContainer: HTMLElement | null = null;\n\n/**\n * Initialize the application\n */\nfunction init(): void {\n  // Get DOM elements\n  gridContainer = document.getElementById('grid');\n  wordListContainer = document.getElementById('word-list');\n  progressContainer = document.getElementById('progress');\n  timerContainer = document.getElementById('timer');\n\n  if (!gridContainer || !wordListContainer || !progressContainer || !timerContainer) {\n    console.error('Required DOM elements not found');\n    return;\n  }\n\n  // Show start screen\n  showStartScreen(handleStartGame);\n}\n\n/**\n * Handle starting the game\n */\nfunction handleStartGame(): void {\n  // Reset state\n  gameState = startGame(createInitialState());\n  selectionState = createInitialSelection();\n  foundCells = new Set();\n\n  // Show game screen\n  showGameScreen();\n\n  // Render initial state\n  renderGrid(gridContainer!, familyPuzzle.grid, foundCells);\n  renderWordList(wordListContainer!, familyPuzzle.words, gameState.foundWords);\n  updateProgress(progressContainer!, 0, familyPuzzle.words.length);\n  initTimerDisplay(timerContainer!);\n\n  // Setup input handlers\n  setupPointerHandlers(gridContainer!, {\n    onTapStart: handleTapStart,\n    onTapEnd: handleTapEnd,\n    onDragStart: handleDragStart,\n    onDragMove: handleDragMoveEvent,\n    onDragEnd: handleDragEnd,\n    onCancel: handleCancel,\n  });\n\n  // Start timer\n  timer = new PrecisionTimer((time) => {\n    updateTimerDisplay(timerContainer!, time);\n  });\n  timer.start();\n}\n\n/**\n * Handle tap start (visual feedback)\n */\nfunction handleTapStart(pos: Position): void {\n  // Just provide visual feedback for the first tap\n  if (!selectionState.isActive) {\n    selectionState = startSelection(pos, 'tap');\n    updateSelectionHighlight(gridContainer!, selectionState.currentPath);\n  }\n}\n\n/**\n * Handle tap end (complete selection or set second point)\n */\nfunction handleTapEnd(pos: Position): void {\n  // If this is the first tap completing (pointerup on same cell as pointerdown),\n  // the selection is already set by handleTapStart - just keep it highlighted\n  if (selectionState.currentPath.length === 1) {\n    const firstCell = selectionState.currentPath[0];\n    if (firstCell && positionsEqual(firstCell, pos)) {\n      // First tap completion - selection already set, nothing more to do\n      return;\n    }\n  }\n\n  const result = handleTapSelection(selectionState, pos);\n  selectionState = result.state;\n\n  if (result.shouldCheck) {\n    // We have start and end - check if it's a valid line and matches a word\n    const path = selectionState.currentPath;\n    if (path.length === 2) {\n      const [start, end] = path;\n      if (start && end && isValidLine(start, end)) {\n        const cells = getLineCells(start, end);\n        checkForMatch(cells);\n      }\n    }\n    // Clear selection after checking\n    selectionState = clearSelection();\n    updateSelectionHighlight(gridContainer!, []);\n  } else {\n    // Update highlight for first tap\n    updateSelectionHighlight(gridContainer!, selectionState.currentPath);\n  }\n}\n\n/**\n * Handle drag start\n */\nfunction handleDragStart(pos: Position): void {\n  selectionState = startSelection(pos, 'drag');\n  updateSelectionHighlight(gridContainer!, selectionState.currentPath);\n}\n\n/**\n * Handle drag move - receives pre-computed path from pointer handler\n */\nfunction handleDragMoveEvent(path: readonly Position[]): void {\n  selectionState = handleDragMove(selectionState, path);\n  updateSelectionHighlight(gridContainer!, selectionState.currentPath);\n}\n\n/**\n * Handle drag end\n */\nfunction handleDragEnd(): void {\n  const result = completeDragSelection(selectionState);\n\n  if (result.shouldCheck) {\n    checkForMatch(selectionState.currentPath);\n  }\n\n  selectionState = clearSelection();\n  updateSelectionHighlight(gridContainer!, []);\n}\n\n/**\n * Handle cancel (pointer left grid, etc.)\n */\nfunction handleCancel(): void {\n  selectionState = clearSelection();\n  updateSelectionHighlight(gridContainer!, []);\n}\n\n/**\n * Check if a selection matches a word\n */\nfunction checkForMatch(cells: readonly Position[]): void {\n  const matchResult = tryMatch(\n    familyPuzzle.grid,\n    cells,\n    familyPuzzle.words,\n    gameState.foundWords,\n  );\n\n  if (matchResult.matched && matchResult.word) {\n    // Update game state\n    gameState = markWordFound(gameState, matchResult.word, familyPuzzle.words.length);\n\n    // Update found cells\n    matchResult.cells.forEach((pos) => {\n      foundCells.add(`${pos.row},${pos.col}`);\n    });\n\n    // Update UI\n    markCellsFound(gridContainer!, matchResult.cells);\n    renderWordList(wordListContainer!, familyPuzzle.words, gameState.foundWords);\n    updateProgress(progressContainer!, gameState.foundWords.size, familyPuzzle.words.length);\n\n    // Check for completion\n    if (gameState.phase === 'complete') {\n      handleGameComplete();\n    }\n  }\n}\n\n/**\n * Handle game completion\n */\nfunction handleGameComplete(): void {\n  const finalTime = timer?.stop() ?? '00:00.00';\n  showCompletionScreen(finalTime, handlePlayAgain);\n}\n\n/**\n * Handle play again\n */\nfunction handlePlayAgain(): void {\n  handleStartGame();\n}\n\n// Initialize on DOM ready\ndocument.addEventListener('DOMContentLoaded', init);\n"],"names":["familyPuzzle","GRID_SIZE","isValidLine","start","end","dRow","dCol","getDirection","getLineCells","cells","direction","length","i","positionsEqual","a","b","snapToDirection","dx","dy","slope","projectToGridCell","startCell","cellSize","gridSize","deltaCols","deltaRows","steps","cellSteps","endRow","endCol","extractWord","grid","row","col","matchWord","candidate","targetWords","reversed","word","tryMatch","foundWords","result","formatWordForDisplay","PrecisionTimer","onTick","elapsed","ms","totalSeconds","minutes","seconds","centiseconds","DRAG_THRESHOLD","tracker","getPositionFromElement","element","target","cell","setupPointerHandlers","gridElement","callbacks","onPointerDown","e","pos","onPointerMove","distance","endPos","path","onPointerUp","onPointerCancel","onPointerLeave","onTouchMove","createInitialSelection","startSelection","mode","clearSelection","handleTapSelection","state","handleDragMove","completeDragSelection","createInitialState","startGame","markWordFound","totalWords","newFoundWords","isComplete","renderGrid","container","foundCells","rowIndex","letter","colIndex","cellKey","isFound","updateSelectionHighlight","markCellsFound","renderWordList","words","list","li","icon","text","updateProgress","found","total","updateTimerDisplay","time","initTimerDisplay","showStartScreen","onStart","screen","gameScreen","completeScreen","startBtn","newBtn","showGameScreen","showCompletionScreen","finalTime","onPlayAgain","timeDisplay","playAgainBtn","gameState","selectionState","timer","gridContainer","wordListContainer","progressContainer","timerContainer","init","handleStartGame","handleTapStart","handleTapEnd","handleDragStart","handleDragMoveEvent","handleDragEnd","handleCancel","firstCell","checkForMatch","matchResult","handleGameComplete","handlePlayAgain"],"mappings":"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"}